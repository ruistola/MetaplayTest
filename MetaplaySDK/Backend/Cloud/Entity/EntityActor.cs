// This file is part of Metaplay SDK which is released under the Metaplay SDK License.

using Akka.Actor;
using Metaplay.Cloud.Entity.EntityStatusMessages;
using Metaplay.Cloud.Entity.Synchronize;
using Metaplay.Cloud.Entity.Synchronize.Messages;
using Metaplay.Cloud.Sharding;
using Metaplay.Core;
using Metaplay.Core.Message;
using Metaplay.Core.Model;
using Metaplay.Core.Serialization;
using Metaplay.Core.TypeCodes;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;

namespace Metaplay.Cloud.Entity
{
    /// <summary>
    /// Topic on which an entity is subscribed to another entity. Can be used to distinguish
    /// which messages are published to which subscribers.
    /// </summary>
    // \todo [petri] most definitions should be userland, use DynamicEnum?
    [MetaSerializable]
    public enum EntityTopic
    {
        Owner = 0,
        Visitor,
        Member,
        Participant,
        Spectator,

        Last,
    }

    /// <summary>
    /// Entity subscription topic flags. Can be used as a mask when publishing messages to
    /// multiple topics.
    /// </summary>
    [Flags]
    public enum EntityTopicFlags
    {
        None    = 0,                            // Empty flags
        Owner   = 1 << EntityTopic.Owner,       // Owner of player state
        All     = ~0
    }

    /// <summary>
    /// Interface representing a subscription channel (in both ways).
    /// </summary>
    public interface IEntityChannel
    {
        EntityId    EntityId        { get; }
        IActorRef   ActorRef        { get; }
        EntityTopic Topic           { get; }
        int         InChannelId     { get; }
        int         OutChannelId    { get; }
    }

    /// <summary>
    /// Represents a subscriber for a given entity.
    /// </summary>
    public class EntitySubscriber : IEntityChannel
    {
        public EntityId     EntityId        { get; private set; }   // EntityId of the subscriber
        public IActorRef    ActorRef        { get; private set; }   // ActorRef of the subsciber
        public EntityTopic  Topic           { get; private set; }   // Topic on which the subscription is on
        public int          InChannelId     { get; private set; }   // ChannelId for incoming messages (generated by self)
        public int          OutChannelId    { get; private set; }   // ChannelId for outgoing messages (generated by subscriber)

        public EntitySubscriber(EntityId entityId, IActorRef actorRef, EntityTopic topic, int inChannelId, int outChannelId)
        {
            EntityId        = entityId;
            ActorRef        = actorRef;
            Topic           = topic;
            InChannelId     = inChannelId;
            OutChannelId    = outChannelId;
        }
    }

    /// <summary>
    /// Represents state of subscription to a specific entity.
    /// </summary>
    public class EntitySubscription : IEntityChannel
    {
        public EntityId     EntityId        { get; private set; }   // EntityId of the subscribed-to entity
        public IActorRef    ActorRef        { get; private set; }   // ActorRef of the subscribed-to entity
        public EntityTopic  Topic           { get; private set; }   // Topic on which the subscription is on
        public int          InChannelId     { get; private set; }   // ChannelId for incoming messages (generated by self)
        public int          OutChannelId    { get; private set; }   // ChannelId for outgoing messages (generated by subscription target)

        public EntitySubscription(EntityId entityId, IActorRef actorRef, EntityTopic topic, int inChannelId, int outChannelId)
        {
            EntityId        = entityId;
            ActorRef        = actorRef;
            Topic           = topic;
            InChannelId     = inChannelId;
            OutChannelId    = outChannelId;
        }
    }

    /// <summary>
    /// The base class for remote exceptions during EntityAsk. Exception must be is MetaSerializable.
    /// </summary>
    [MetaSerializable]
    public abstract class EntityAskExceptionBase : Exception
    {
        protected EntityAskExceptionBase() { }

        public abstract override string Message { get; }
    }

    /// <summary>
    /// Base class for communicating refusal in entity asks via exceptions.
    /// <para>
    /// EntityAskRefusals thrown from entity ask handlers are propagated to the ask source via serializing the contents and
    /// raising the exception at the call site of the source. The contract for the entity ask handler is that when an
    /// EntityAskRefusal is thrown the callee actor must remain in a well-defined state, in particular the actor of the handler
    /// is not terminated when an EntityAskRefusal is thrown.
    /// </para>
    /// <para>
    /// A single <c>EntityAskRefusal</c> instance is tied to the Entity that throws it the first time. If caller Entity
    /// rethrows the same exception instance, or any exception instance that is not tied to itself, the exception is handled as
    /// if any unhandled exception causing actor to terminate. This means that Entity Ask can only be refused by explicitly
    /// throwing a new EntityAskRefusal in the handler. This prevents unintended ask rejection if an entity ask handler performs
    /// another entity ask, which then is rejected. If the outer ask does not handle the rejection, the rejection would get rethrown
    /// causing the outer ask to be rejected too. This is unexpected as unhandled exceptions should terminate the actor.
    /// </para>
    /// </summary>
    public abstract class EntityAskRefusal : EntityAskExceptionBase
    {
        /// <summary>
        /// The Entity that throwed the exception. <c>None</c> if the current entity.
        /// </summary>
        [MetaMember(200)] public EntityId OriginEntity { get; set; }

        protected EntityAskRefusal() { }
    }

    /// <summary>
    /// A simple EntityAskRefusal containing a single error string.
    /// </summary>
    [MetaSerializableDerived(1)]
    public class InvalidEntityAsk : EntityAskRefusal
    {
        [MetaMember(1)] public string Error { get; private set; }

        private InvalidEntityAsk() { }
        public InvalidEntityAsk(string s)
        {
            Error = s;
        }

        public override string Message => Error;
    }

    /// <summary>
    /// A generic "ok" response from entity asks with no payload
    /// </summary>
    [MetaMessage(MessageCodesCore.EntityAskOk, MessageDirection.ServerInternal)]
    public class EntityAskOk : MetaMessage
    {
        private EntityAskOk() { }
        public static EntityAskOk Instance = new EntityAskOk();
    }


    /// <summary>
    /// Request handling of a message. The message handler itself does not return, but a
    /// <see cref="HandleMessageResponse"/> is returned on successful execution. On failure,
    /// a <see cref="EntityShard.RemoteEntityError"/> is returned instead.
    /// </summary>
    [MetaMessage(MessageCodesCore.HandleMessageRequest, MessageDirection.ServerInternal)]
    public class HandleMessageRequest : MetaMessage
    {
        public MetaMessage Message { get; private set; }

        private HandleMessageRequest() { }
        public HandleMessageRequest(MetaMessage message) => Message = message;
    }

    [MetaMessage(MessageCodesCore.HandleMessageResponse, MessageDirection.ServerInternal)]
    public class HandleMessageResponse : MetaMessage
    {
        public static readonly HandleMessageResponse Instance = new HandleMessageResponse();
    }

    public interface IEntityReceiver
    {
        void ReplyToAsk(EntityShard.EntityAsk ask, MetaMessage reply);
    }

    public interface IEntityAsker
    {
        /// <summary>
        /// Sends <paramref name="request"/> to the given <paramref name="entity"/>, where it is handled by the entity's [EntityAskHandler] for that message type.
        /// Returns the result of ask as computed by the target entity ask handler.
        /// </summary>
        /// <exception cref="EntityAskRefusal">when target entity handler method throws an <see cref="EntityAskRefusal"/></exception>
        /// <exception cref="EntityShard.UnexpectedEntityAskError">when target entity crashes due to handler throwing an unhandled </exception>
        /// <exception cref="TimeoutException">if no response is received within a reasonable time</exception>
        Task<TResult> EntityAskAsync<TResult>(EntityId entity, MetaMessage request) where TResult : MetaMessage;
    }

    /// <summary>
    /// Base actor class for all game entities. Provides various services over pure actors, such as message routing in cluster,
    /// more convenient async command/message handlers, AskAsync(), etc.
    /// </summary>
    // \todo [petri] better docs
    public abstract partial class EntityActor : MetaReceiveActor, IEntityReceiver, IEntityAsker, IEntitySynchronizeCallbacks
    {
        // Metrics

        static readonly Prometheus.HistogramConfiguration c_entityAskDurationConfig = new Prometheus.HistogramConfiguration
        {
            Buckets     = Metaplay.Cloud.Metrics.Defaults.LatencyDurationBuckets,
            LabelNames  = new string[] { "message" },
        };
        static readonly Prometheus.HistogramConfiguration c_entitySyncOpenDurationConfig = c_entityAskDurationConfig;
        static readonly Prometheus.HistogramConfiguration c_entitySyncDurationConfig = new Prometheus.HistogramConfiguration
        {
            Buckets     = Metaplay.Cloud.Metrics.Defaults.LatencyDurationBuckets,
            LabelNames  = new string[] { "message", "peer" },
        };

        static readonly Prometheus.Counter      c_entityAsks                = Prometheus.Metrics.CreateCounter("game_entity_asks_total", "Total amount of EntityAsk performed by message type", "message");
        static readonly Prometheus.Counter      c_entityAskErrors           = Prometheus.Metrics.CreateCounter("game_entity_ask_errors_total", "Total amount of errors during EntityAsks by message type and reason", "message", "reason");
        static readonly Prometheus.Histogram    c_entityAskDuration         = Prometheus.Metrics.CreateHistogram("game_entity_ask_duration", "Duration of successful EntityAsks by message type", c_entityAskDurationConfig);
        static readonly Prometheus.Counter      c_entitySubscribes          = Prometheus.Metrics.CreateCounter("game_entity_subscribes_total", "Total amount of entity subscriptions by target entity type", "target");
        static readonly Prometheus.Counter      c_entitySubscribeErrors     = Prometheus.Metrics.CreateCounter("game_entity_subscribe_errors_total", "Total amount of errors during entity subscriptions by target type", "target", "reason");
        static readonly Prometheus.Counter      c_entityUnsubscribes        = Prometheus.Metrics.CreateCounter("game_entity_unsubscribes_total", "Total amount of entity subscriptions ended by target entity type", "target");
        static readonly Prometheus.Counter      c_entitySubscriberKicked    = Prometheus.Metrics.CreateCounter("game_entity_subscribers_kicked_total", "Total amount of entity subscriptions ended by getting kicked (by target entity type)", "target");
        static readonly Prometheus.Counter      c_entitySyncs               = Prometheus.Metrics.CreateCounter("game_entity_syncs_total", "Total amount of EntitySynchronize performed by opening message type", "message");
        static readonly Prometheus.Counter      c_entitySyncErrors          = Prometheus.Metrics.CreateCounter("game_entity_sync_errors_total", "Total amount of errors during EntitySynchronize by opening message type", "message", "reason");
        static readonly Prometheus.Histogram    c_entitySyncOpenDuration    = Prometheus.Metrics.CreateHistogram("game_entity_sync_open_duration", "Duration of successful EntitySynchronize init by opening message type", c_entitySyncOpenDurationConfig);
        static readonly Prometheus.Histogram    c_entitySyncDuration        = Prometheus.Metrics.CreateHistogram("game_entity_sync_duration", "Duration of successful EntitySynchronize from beginning to end by opening message type and peer", c_entitySyncDurationConfig);

        // Members

        protected EntityId                  _entityId { get; }

        protected EntityDispatcher          _dispatcher { get; }
        protected DateTime                  _spawnTime              = DateTime.UtcNow;

        int                                 _runningChannelId       = 1;        // RunningId for subscription channels
        ICancelable                         _cancelTimers           = new Cancelable(Context.System.Scheduler);

        static Dictionary<EntityKind, List<Type>> s_concreteComponentTypes = new Dictionary<EntityKind, List<Type>>();
        protected EntityComponent[] _components { get; }

        /// <summary>
        /// The IActorRef of the parent <see cref="Metaplay.Cloud.Sharding.EntityShard"/> actor.
        /// </summary>
        protected readonly IActorRef _shard;

        protected EntityActor(EntityId entityId)
        {
            if (!entityId.IsValid)
                throw new ArgumentException($"Invalid EntityId {entityId}", nameof(entityId));
            _entityId = entityId;
            _components = InitializeComponents(entityId.Kind);
            _dispatcher = EntityDispatcherRegistry.Get(entityId.Kind);

            InitializeContinueTaskOnActorContext();

            // Message handlers
            RegisterHandlers();

            _shard = Context.Parent;
        }

        // Reads the EntityComponentTypes config and translates declared component types into concrete integration implementation types.
        // This assumes that the component implementations always require an integration class, if the integration class is not defined
        // then the corresponding component is ignored.
        [EntityActorRegisterCallback]
        static void RegisterComponentTypes(EntityConfigBase config)
        {
            List<Type> components = new List<Type>();
            foreach (Type componentType in config.EntityComponentTypes)
            {
                if (componentType.ImplementsInterface<IMetaIntegration>())
                {
                    IEnumerable<Type> concreteTypes = IntegrationRegistry.GetIntegrationClasses(componentType);
                    if (concreteTypes.Count() > 1)
                        throw new Exception($"Multiple concrete implementation classes for EntityComponent type {componentType} found: {string.Join(',', concreteTypes.Select(x => x.Name))}");

                    Type concreteType = concreteTypes.SingleOrDefault();
                    if (concreteType != null)
                        components.Add(concreteType);
                }
                else
                {
                    components.Add(componentType);
                }
            }
            if (components.Count > 0)
            {
                s_concreteComponentTypes[config.EntityKind] = components;
            }
        }

        public static bool TryGetComponentTypes(EntityKind kind, out List<Type> types)
        {
            return s_concreteComponentTypes.TryGetValue(kind, out types);
        }

        // Instantiate component implementations for the concrete component classes discovered in `RegisterComponentTypes`.
        // Components instances are assigned to the `_components` array by their index in the `_concreteComponentTypes` list
        // and the message dispatcher uses this index when routing messages to the appropriate receiver component.
        EntityComponent[] InitializeComponents(EntityKind kind)
        {
            if (!s_concreteComponentTypes.TryGetValue(kind, out List<Type> componentTypes))
                return null;
            EntityComponent[] components = new EntityComponent[componentTypes.Count];
            foreach ((Type componentType, int componentIndex) in componentTypes.ZipWithIndex())
            {
                components[componentIndex] = CreateComponent(componentType);
            }
            return components;
        }

        public EntityComponent GetComponentByIndex(int index)
        {
            return _components[index];
        }

        // The integration hook for creating an instance of an EntityComponent as part of EntityActor construction.
        // When a concrete implementation of a supported EntityComponent exists, the integration must implement
        // this method for the integration type. Derived SDK classes may further specialize the creation function for
        // the component types they support.
        protected virtual EntityComponent CreateComponent(Type componentType)
        {
            throw new NotImplementedException($"EntityActor of type {GetType()} does not implement CreateComponent for component type {componentType}");
        }

        protected override void PreStart()
        {
            base.PreStart();
            InitializeExecuteOnActorContext();
            InitializeScheduleExecuteOnActorContext();
        }

        protected override void PostStop()
        {
            base.PostStop();
        }

        protected virtual void RegisterHandlers()
        {
            RegisterShutdownHandlers();

            ReceiveAsync<ShutdownEntity>(ReceiveShutdownEntity);
            Receive<Terminated>(ReceiveTerminated);
            ReceiveAsync<PubSub.WatchedEntityTerminated>(ReceiveWatchedEntityTerminated);
            ReceiveAsync<EntityShard.EntityAsk>(ReceiveEntityAsk);
            ReceiveAsync<EntitySynchronizationS2EBeginRequest>(ReceiveEntitySync);
            ReceiveAsync<EntityShard.IRoutedMessage>(ReceiveRoutedMessage);
            ReceiveAsync<PubSub.PubSubMessage>(ReceivePubSubMessage);
            ReceiveAsync<object>(ReceiveObject);
        }

        private async Task ReceiveShutdownEntity(ShutdownEntity shutdown)
        {
            await OnShutdown();
            Context.Stop(_self);

            _cancelTimers.Cancel();
            CancelAllPendingOnActorContextTasksForEntityShutdown();
            CancelAllScheduledExecuteOnActorContextTasksForEntityShutdown();
        }

        void ReceiveTerminated(Terminated terminated)
        {
            //_log.Warning("Terminated: actor={0}, address={1}, existed={2}", terminated.ActorRef, terminated.AddressTerminated, terminated.ExistenceConfirmed);

            // Invoke OnTerminated() for unknown actors
            OnTerminated(terminated);
        }

        async Task ReceiveEntityAsk(EntityShard.EntityAsk ask)
        {
            //_log.Debug("EntityAsk: from={0}, ownerShard={1}, target={2}", ask.FromEntityId, ask.OwnerShard, ask.TargetEntityId);
            try
            {
                MetaMessage message = ask.Message.Deserialize(resolver: null, logicVersion: null);
                switch (message)
                {
                    case PubSub.Subscribe subscribe:
                        await InternalHandlePubSubSubscribeAskAsync(ask, subscribe);
                        return;

                    case PubSub.Unsubscribe unsubscribe:
                        await InternalHandlePubSubUnsubscribeAskAsync(ask, unsubscribe);
                        return;

                    default:
                        try
                        {
                            //_log.Warning("Unknown EntityAsk message from {0}: {1}", ask.FromEntityId, PrettyPrint.Compact(ask.Message));
                            if (_dispatcher.TryGetEntityAskDispatchFunc(message.GetType(), out EntityDispatcher.DispatchEntityAsk dispatchFunc))
                                await dispatchFunc(this, ask, message).ConfigureAwait(false);
                            else
                                await HandleUnknownEntityAsk(ask, message).ConfigureAwait(false);
                        }
                        catch (EntityAskRefusal error) when (error.OriginEntity == EntityId.None)
                        {
                            // Entity ask handler threw a controlled exception, propagate to caller
                            error.OriginEntity = _entityId;
                            Tell(ask.OwnerShard, EntityShard.EntityAskReply.FailWithError(ask.Id, ask.FromEntityId, _entityId, error));
                        }
                        return;
                }
            }
            catch (Exception ex)
            {
                // Respond with error & propagate exception
                _log.Error("Unhandled exception when handling EntityAsk<{EntityAskType}>: {Exception}", MetaSerializationUtil.PeekMessageName(ask.Message), ex);
                // \note This may double-respond in case the handler responded, but then failed -- should not be a problem, though
                Tell(ask.OwnerShard, EntityShard.EntityAskReply.FailWithUnexpectedError(ask.Id, ask.FromEntityId, _entityId, ex));
                throw;
            }
        }

        async Task ReceiveRoutedMessage(EntityShard.IRoutedMessage routed)
        {
            EntityId fromEntityId = routed.FromEntityId;
            MetaMessage msg = routed.Message.Deserialize(resolver: null, logicVersion: null);

            if (msg is PubSub.SubscriberKicked kicked)
                await InternalHandlePubSubKickedAsync(kicked);
            else if (_dispatcher.TryGetMessageDispatchFunc(msg.GetType(), out EntityDispatcher.DispatchMessage dispatchFunc))
                await dispatchFunc(this, fromEntityId, msg).ConfigureAwait(false);
            else
                await HandleUnknownMessage(fromEntityId, msg).ConfigureAwait(false);
        }

        async Task ReceiveEntitySync(EntitySynchronizationS2EBeginRequest syncReq)
        {
            Stopwatch sw = Stopwatch.StartNew();
            MetaMessage message = syncReq.Message.Deserialize(resolver: null, logicVersion: null);

            if (!_dispatcher.TryGetEntitySynchronizeDispatchFunc(message.GetType(), out EntityDispatcher.DispatchEntitySynchronize dispatchFunc))
            {
                _log.Warning("Unknown EntitySynchronize message from {0}: {1}", syncReq.FromEntityId, PrettyPrint.Compact(syncReq.Message));
                return;
            }

            // Reply to shard we have established Sync.
            string openingMessageType = MetaMessageRepository.Instance.GetFromType(message.GetType()).Name;
            Channel<MetaSerialized<MetaMessage>> syncChannel = Channel.CreateUnbounded<MetaSerialized<MetaMessage>>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = true });
            EntitySynchronizationS2EBeginResponse response = new EntitySynchronizationS2EBeginResponse(
                channelId:      syncReq.ChannelId,
                fromEntityId:   _entityId,
                writerPeer:     syncChannel.Writer
                );
            Tell(_shard, response);

            // Initiate sync processing
            // \note: Dispose() is called manually and only if dispatchFunc completes successfully. This means
            //        that caller will receive EOF only if dispatchFunc completed successfully. If dispatchFunc
            //        throws, caller will not receive EOF (unless dispatchFunc has explicitly Disposed the
            //        EntitySynchronize before throwing).
            EntitySynchronize synchronize = new EntitySynchronize(this, _entityId, syncReq.FromEntityId, syncReq.ChannelId, syncChannel.Reader, sw, label: openingMessageType, isCaller: false);
            await dispatchFunc(this, synchronize, message);
            synchronize.Dispose();

            return;
        }

        async Task ReceiveObject(object command)
        {
            if (_dispatcher.TryGetCommandDispatchFunc(command.GetType(), out EntityDispatcher.DispatchCommand dispatchFunc))
                await dispatchFunc(this, command).ConfigureAwait(false);
            else
                HandleUnknownCommand(command);
        }

        /// <summary>
        /// Start a timer which periodically sends a message to the actor itself. The initial delay
        /// is the same as the send interval. Automatically handles canceling the timer when the
        /// actor stops.
        /// </summary>
        /// <param name="interval">Time span between messages after the initial one (also the initial delay)</param>
        /// <param name="message">Message to send</param>
        protected void StartPeriodicTimer(TimeSpan interval, object message)
        {
            StartPeriodicTimer(interval, interval, message);
        }

        /// <summary>
        /// Start a timer which periodically sends a message to the actor itself. The initial delay
        /// and interval can be configured separately. Automatically handles canceling the timer
        /// when the actor stops.
        /// </summary>
        /// <param name="initialDelay">Time span after which the initial message it sent</param>
        /// <param name="interval">Time span between messages after the initial one</param>
        /// <param name="message">Message to send</param>
        protected void StartPeriodicTimer(TimeSpan initialDelay, TimeSpan interval, object message)
        {
            Context.System.Scheduler.ScheduleTellRepeatedly(initialDelay, interval, _self, message, _self, _cancelTimers);
        }

        /// <summary>
        /// Start a timer which periodically sends a message to the actor itself. The initial delay
        /// is the interval multiplied by a random factor in range [0.5; 1.5] which helps even out the
        /// events in case of multiple timers started in close proximity (eg, by lots of logins within
        /// a short period of time). Automatically handles canceling the timer when the actor stops.
        /// </summary>
        /// <param name="interval"></param>
        /// <param name="message"></param>
        protected void StartRandomizedPeriodicTimer(TimeSpan interval, object message)
        {
            Random rnd = new Random();
            double multiplier = rnd.NextDouble() + 0.5;
            TimeSpan initialDelay = TimeSpan.FromSeconds(multiplier * interval.TotalSeconds);
            Context.System.Scheduler.ScheduleTellRepeatedly(initialDelay, interval, _self, message, _self, _cancelTimers);
        }

        /// <summary>
        /// Respond to a given <see cref="EntityShard.EntityAsk"/> message.
        /// </summary>
        /// <param name="ask">Context of original ask that is being responded to</param>
        /// <param name="reply">Reply message to send to asker</param>
        public void ReplyToAsk(EntityShard.EntityAsk ask, MetaMessage reply)
        {
            //_log.Debug("ReplyToAsk: from={0}, ownerShard={1}, target={2}, reply={3}", ask.FromEntityId, ask.OwnerShard, ask.TargetEntityId, PrettyPrint.Compact(reply));
            MetaSerialized<MetaMessage> serialized = MetaSerialization.ToMetaSerialized(reply, MetaSerializationFlags.IncludeAll, logicVersion: null);
            Tell(ask.OwnerShard, EntityShard.EntityAskReply.Success(ask.Id, ask.FromEntityId, _entityId, serialized));
        }

        /// <summary>
        /// Refuse a given <see cref="EntityShard.EntityAsk"/> message.
        /// This will cause the asker's ask Task to fault with the given error.
        /// </summary>
        /// <param name="ask">Context of original ask that is being refused</param>
        /// <param name="error">The error to send to the asker</param>
        public void RefuseAsk(EntityShard.EntityAsk ask, EntityAskRefusal error)
        {
            error.OriginEntity = _entityId;
            Tell(ask.OwnerShard, EntityShard.EntityAskReply.FailWithError(ask.Id, ask.FromEntityId, _entityId, error));
        }

        /// <summary>
        /// Returns the <see cref="EntityId"/> of a service associated with this Entity. The associated service <see cref="EntityId"/>
        /// is computed by simple hash from this Entity's own <see cref="EntityId"/>.
        /// </summary>
        /// <param name="targetEntityKind"></param>
        /// <returns></returns>
        protected EntityId GetAssociatedServiceEntityId(EntityKind targetEntityKind)
        {
            EntityKindShardState shard = EntitySharding.Get(Context.System).GetShardStatesForKind(targetEntityKind);
            return EntityId.Create(targetEntityKind, _entityId.Value % (uint)shard.ShardActors.Length);
        }

        protected void CastMessage(EntityId targetEntityId, MetaMessage message)
        {
            // Check for valid target
            if (!targetEntityId.IsValid)
                throw new ArgumentException($"targetEntityId must be a valid entity (got {targetEntityId})", nameof(targetEntityId));

            //_log.Debug("Casting to {0}: {1}", targetEntityId, message.GetType().Name);
            MetaSerialized<MetaMessage> msg = MetaSerialization.ToMetaSerialized(message, MetaSerializationFlags.IncludeAll, logicVersion: null);
            Tell(_shard, new EntityShard.CastMessage(targetEntityId, msg, _entityId));
        }

        public Task<TResult> EntityAskAsync<TResult>(EntityId targetEntityId, MetaMessage message) where TResult : MetaMessage
        {
            string msgTypeName = MetaMessageRepository.Instance.GetFromType(message.GetType()).Name;
            return InternalEntityAskAsync<TResult>(targetEntityId, message, timeout: TimeSpan.FromMilliseconds(10_000), metricsLabel: msgTypeName);
        }

        async Task<TResult> InternalEntityAskAsync<TResult>(EntityId targetEntityId, MetaMessage message, TimeSpan timeout, string metricsLabel) where TResult : MetaMessage
        {
            // Check for valid target
            if (!targetEntityId.IsValid)
                throw new ArgumentException($"targetEntityId must be a valid entity (got {targetEntityId})", nameof(targetEntityId));
            if (message == null)
                throw new ArgumentNullException(nameof(message));

            // Track metrics
            Stopwatch sw = Stopwatch.StartNew();
            c_entityAsks.WithLabels(metricsLabel).Inc();

            // Create promise for result
            TaskCompletionSource<MetaSerialized<MetaMessage>> promise = new TaskCompletionSource<MetaSerialized<MetaMessage>>(TaskCreationOptions.RunContinuationsAsynchronously);

            // Send EntityAsk via parent shard
            MetaSerialized<MetaMessage> msg = MetaSerialization.ToMetaSerialized(message, MetaSerializationFlags.IncludeAll, logicVersion: null);
            Tell(_shard, new EntityShard.EntityAsk(targetEntityId, msg, _entityId, promise));

            // Wait for response (or timeout)
            Task<MetaSerialized<MetaMessage>> task = promise.Task;
            Task finished = await Task.WhenAny(task, Task.Delay(timeout)).ConfigureAwait(false);
            if (finished == task)
            {
                c_entityAskDuration.WithLabels(metricsLabel).Observe(sw.Elapsed.TotalSeconds);

                // Propagate exceptions due to failed routing/handling
                if (task.IsFaulted)
                {
                    // \note This flattening code is duplicated in AdminApiActor.ReceiveForwardAskToEntity

                    AggregateException flattened = task.Exception.Flatten();
                    Exception effectiveException = flattened.InnerException is EntityAskExceptionBase askException ? askException : flattened;

                    // \note EntityAskRefusals are not counted in ask error metrics, because they are "controlled"
                    //       errors and are sometimes used for non-erroneous communication, for example
                    //       InternalPlayerSessionSubscribeRefused.
                    // \todo Even these should be considered erroneous if the asker doesn't actually handle the
                    //       exception. But that's not really detectable here...
                    if (!(effectiveException is EntityAskRefusal))
                        c_entityAskErrors.WithLabels(metricsLabel, "exception").Inc();

                    throw effectiveException;
                }

                // Deserialize and return result
                MetaMessage result = task.GetCompletedResult().Deserialize(resolver: null, logicVersion: null);
                if (result is TResult typed)
                    return typed;
                else
                {
                    c_entityAskErrors.WithLabels(metricsLabel, "invalidResponse").Inc();
                    throw new InvalidOperationException($"Invalid response type for EntityAskAsync<{typeof(TResult).ToGenericTypeString()}>({message.GetType().ToGenericTypeString()}) from {_entityId} to {targetEntityId}: got {result?.GetType().ToGenericTypeString() ?? "null"} (expecting {typeof(TResult).ToGenericTypeString()})");
                }
            }
            else
            {
                c_entityAskErrors.WithLabels(metricsLabel, "timeout").Inc();
                throw new TimeoutException($"Timeout during EntityAskAsync<{typeof(TResult).ToGenericTypeString()}>({message.GetType().ToGenericTypeString()}) from {_entityId} to {targetEntityId}");
            }
        }

        /// <summary>
        /// Establishes a synchronized execution and a message channel between the caller and the target entity handler. Similarly
        /// to EntityAsk, the <paramref name="message"/> is delivered to the <c>Actor.HandleEntitySynchronize(EntitySynchronize sync, MessageType msg)</c>
        /// overload of the matching type.
        ///
        /// <para>
        /// EntitySynchronize is a superset of EntityAsk. Instead of a single query and a single response, EntitySynchronize allows any number of
        /// messages to be sent and received on both sides during a single handler. During an ongoing EntitySynchronize, target entity does not
        /// have any other forward progress than executing the entity synchronize. In particular, any messages sent outside the EntitySynchronize
        /// channel are queued up and processed later. This mechanism allows EntitySynchronize to synchronize the execution with the <paramref name="targetEntityId"/>
        /// as each Send-Receive pair forms an execution fence.
        /// </para>
        ///
        /// <para>
        /// Call to EntitySynchronizeAsync completes when the initial message is delivered to the <c>Actor.HandleEntitySynchronize(EntitySynchronize sync, MessageType msg)</c>
        /// handler of the target entity, but does not guarantee any progress is made beyond that. To observe progress, the target entity should send
        /// a reply on the <c>EntitySynchronize</c> channel, and caller await for it.
        /// </para>
        ///
        /// <para>
        /// Caller MUST dispose the returned <see cref="EntitySynchronize"/>.
        /// </para>
        /// </summary>
        protected async Task<EntitySynchronize> EntitySynchronizeAsync(EntityId targetEntityId, MetaMessage message)
        {
            // Check for valid target
            if (!targetEntityId.IsValid)
                throw new ArgumentException($"targetEntityId must be a valid entity (got {targetEntityId})", nameof(targetEntityId));

            // Track metrics
            string openingMessageType = MetaMessageRepository.Instance.GetFromType(message.GetType()).Name;
            Stopwatch sw = Stopwatch.StartNew();
            c_entitySyncs.WithLabels(openingMessageType).Inc();

            // Let parent shard take care of this
            TaskCompletionSource<int> openingPromise = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);
            Channel<MetaSerialized<MetaMessage>> syncChannel = Channel.CreateUnbounded<MetaSerialized<MetaMessage>>(new UnboundedChannelOptions() { SingleReader = true, SingleWriter = true, AllowSynchronousContinuations = false });

            MetaSerialized<MetaMessage> serializedMessage = MetaSerialization.ToMetaSerialized(message, MetaSerializationFlags.IncludeAll, logicVersion: null);
            EntitySynchronizationE2SBeginRequest request = new EntitySynchronizationE2SBeginRequest(
                targetEntityId: targetEntityId,
                fromEntityId:   _entityId,
                message:        serializedMessage,
                openingPromise: openingPromise,
                writerPeer:     syncChannel.Writer
                );
            Tell(_shard, request);

            // Wait for response (or timeout)
            Task<int> openingTask = openingPromise.Task;
            Task finished = await Task.WhenAny(openingTask, Task.Delay(10_000)).ConfigureAwait(false);
            if (finished != openingTask)
            {
                c_entitySyncErrors.WithLabels(openingMessageType, "timeout").Inc();
                throw new TimeoutException($"Timeout during EntitySynchronizeAsync<{message.GetType().Name}> from {_entityId} to {targetEntityId}");
            }

            c_entitySyncOpenDuration.WithLabels(openingMessageType).Observe(sw.Elapsed.TotalSeconds);

            int channelId = openingTask.GetCompletedResult();
            EntitySynchronize synchronize = new EntitySynchronize(this, _entityId, targetEntityId, channelId, syncChannel.Reader, sw, label: openingMessageType, isCaller: true);
            return synchronize;
        }

        void IEntitySynchronizeCallbacks.EntitySynchronizeSend(EntitySynchronize sync, MetaMessage message)
        {
            MetaSerialized<MetaMessage> serializedMessage = MetaSerialization.ToMetaSerialized(message, MetaSerializationFlags.IncludeAll, logicVersion: null);
            Tell(_shard, new EntitySynchronizationE2SChannelMessage(
                fromEntityId:   _entityId,
                channelId:      sync.ChannelId,
                message:        serializedMessage
                ));
        }

        void IEntitySynchronizeCallbacks.EntitySynchronizeDispose(EntitySynchronize sync)
        {
            string peerLabel = sync.IsCaller ? "sender" : "receiver";
            c_entitySyncDuration.WithLabels(sync.Label, peerLabel).Observe(sync.Elapsed.TotalSeconds);
            Tell(_shard, new EntitySynchronizationE2SChannelMessage(
                fromEntityId:   _entityId,
                channelId:      sync.ChannelId,
                message:        new MetaSerialized<MetaMessage>()
                ));
        }

        [CommandHandler]
        public async Task HandleEntityShardInitializeEntity(InitializeEntity initialize)
        {
            // Initialize entity
            await Initialize();

            // Inform shard we're ready for business
            Tell(_shard, EntityReady.Instance);

            // We are now Running, start autoshutdown logic.
            InitializeShutdown();
        }

        /// <summary>
        /// Request execution of a message handler using the EntityAsk pattern. This allows any errors be returned back
        /// to the caller. This is mainly used by the dashboard, to make sure that any errors are routed back to the AdminApi
        /// and can be shown to the dashboard user.
        /// </summary>
        /// <param name="ask"></param>
        /// <param name="request"></param>
        /// <returns></returns>
        [EntityAskHandler]
        async Task HandleHandleMessageRequest(EntityShard.EntityAsk ask, HandleMessageRequest request)
        {
            MetaMessage msg = request.Message;
            if (_dispatcher.TryGetMessageDispatchFunc(msg.GetType(), out EntityDispatcher.DispatchMessage dispatchFunc))
                await dispatchFunc(this, ask.FromEntityId, msg).ConfigureAwait(false);
            else
                await HandleUnknownMessage(ask.FromEntityId, msg).ConfigureAwait(false);

            ReplyToAsk(ask, HandleMessageResponse.Instance);
        }

        protected virtual Task Initialize() { return Task.CompletedTask; }
        protected virtual Task OnShutdown() { return Task.CompletedTask; }
        protected virtual void HandleUnknownCommand(object command) => _log.Warning("Received unknown command from {Sender}: {CommandName}", Sender, command.GetType().ToNamespaceQualifiedTypeString());
        protected virtual Task HandleUnknownMessage(EntityId fromEntityId, MetaMessage message) { _log.Warning("Received unknown message from {EntityId}: {Message}", fromEntityId, PrettyPrint.Compact(message)); return Task.CompletedTask; }
        protected virtual Task HandleUnknownEntityAsk(EntityShard.EntityAsk ask, MetaMessage message) { _log.Warning("Received unknown ask from {EntityId}: {Message}", ask.FromEntityId, PrettyPrint.Compact(message)); return Task.CompletedTask; }

        protected virtual void OnTerminated(Terminated terminated) { _log.Warning("Unhandled Terminated: {Actor}", terminated.ActorRef); }
    }

    /// <summary>
    /// EntityComponents represent modular behaviour components of an Entity.
    /// </summary>
    ///
    /// <remarks>
    /// Components can encapsulate actor state associated with a given (optional) feature and declare message handler methods in the same way that
    /// is supported for EntityActors. Internally the owner EntityActor routes received messages the the component based on the message type. The
    /// execution context for these handlers is the owner actor context.
    ///
    /// Supported component types for an EntityKind are declared in the EntityConfig for the entity. When the supported component type is abstract,
    /// the component is automatically enabled when an integration of the abstract class is found.
    /// </remarks>
    public abstract class EntityComponent : IEntityReceiver
    {
        protected abstract EntityActor OwnerActor { get; }

        public void ReplyToAsk(EntityShard.EntityAsk ask, MetaMessage reply)
        {
            OwnerActor.ReplyToAsk(ask, reply);
        }
    }
}
